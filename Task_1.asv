%%Estimating pi using Monte Carlo Algorithm
%This script estimates the value of pi using a Monte Carlo method.
%Random points are generated in the unit square [0,1] x [0,1], and the
% ratio of points inside the unit circle (radius 0.5, centered at (0.5,0.5))
% is used to approximate pi.
%
% DESCRIPTION:
%   - The simulation is repeated for N values ranging from 100 to 100,000.
%   - For each N:
%       * A timer (tic/toc) is used to measure runtime.
%       * Pi is estimated from the fraction of points inside the circle.
%       * The absolute error from MATLAB's built-in pi is computed.
%   - Results are stored in vectors for later analysis.
%
% VARIABLES (in workspace after execution):
%   N              - Vector of sample sizes used (number of random points).
%   estimatedPiVec - Vector of estimated pi values for each N.
%   errorVec       - Vector of absolute errors |estimated pi - pi|.
%   timeElapsed    - Vector of elapsed times (seconds) per iteration.
%
% FIGURES:
%   1. Scatter plot of estimated pi (red) and error (blue) vs. N.
%   2. Scatter plot of error vs. time elapsed.
%
% NOTES:
%   - The inner loop recomputes pi for each N separately (no cumulative reuse).
%   - Runtime grows with N; for very large N, consider vectorized approaches
%     to improve performance.

N = []; %initialize empty vector N to store how many points were used
errorVec = []; %initialize empty vector to store the errors we attain
timeElapsed = []; %initialize empty vector to measure the time elapsed per iteration
estimatedPiVec = []; %initialize empty vector to keep the estimated pi per iteration

for i = linspace(100, 100000, 999)
    tic; %start timer
    %repeat the Monte Carlo simulation for each value of N
    insideCircle = 0; %reset count for each iteration
    for j = 1:i
        x = rand(1); %random real number between 0 and 1
        y = rand(1);
        dist = sqrt((x - 0.5)^2 + (y - 0.5)^2); %if this distance is more than 0.5, we are outside the circle
        if dist <= 0.5
            insideCircle = insideCircle + 1; %since we're inside the circle, we add 1 to inside Circle
        end
    end
    estimatedPi = 4 * (insideCircle / i); %estimated pi from Monte Carlo
    piError = abs(estimatedPi - pi); %using absolute error

    N(end+1) = i; %store the current number of points used
    errorVec(end+1) = piError; %store the current error
    timeElapsed(end+1) = toc; %store the elapsed time for the current iteration
    estimatedPiVec(end+1) = estimatedPi; %store estimated pi calculations
end

%plot of estimated pi and its absolute error from true pi
scatter(N, errorVec, "b.");
hold on;
xlabel("Number of points thrown (N)"); 
%no need for y label as we're overlaying two plots
title("Monte Carlo pi Error");
scatter(N, estimatedPiVec, "r."); %estimated pi scatter overlayed
grid on;

%new figure to plot execution time against error
figure;
scatter(timeElapsed, errorVec, "b.");
%add labels and title to the second scatter plot
xlabel("Time Elapsed (s)");
ylabel("Error from pi");
title("Monte Carlo pi Error vs Time Elapsed");
grid on;